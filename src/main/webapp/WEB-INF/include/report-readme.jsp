<tr>
    <td style="padding: 20px">
        <h3 style="text-align: center">Readme</h3><br><br>

        <h4>Requirements</h4><br>

        <span style="font-weight:bold">Tomcat 8 or higher:</span> If running on Tomcat 7 or below, you will need to go into WEB-INF/web.xml and change the web-app version descriptor to whatever version is supported by that Tomcat instance. Refer to these links: <a href="http://tomcat.apache.org/whichversion.html">Apache Tomcat Versions</a> and <a href="http://www.mkyong.com/web-development/the-web-xml-deployment-descriptor-examples/">Web.xml Deployment Descriptor Examples</a><br><br>
        
        <span style="font-weight:bold">Java 8 JRE or higher:</span> The code might compile under Java 7 but definitely not Java 6 or lower since there are a couple places we use the try-with-resources statement introduced in Java 7.<br><br>

        <span style="font-weight:bold">MySQL 5.7 or higher:</span> The project may work with MySQL 5.5, but there are some features like indexing which are better implemented on 5.7.<br><br>

        <h4>Master/Slave Setup Information (Project 5)</h4><br>

        <span style="font-weight:bold">Master Private IP:</span> 172.31.0.57<br>
        <span style="font-weight:bold">Slave Private IP:</span> 172.31.14.39<br><br>

        The installation instructions below are for the single instance deployment utilized for Projects 1-4. In order to deploy the webapp to the master/slave version, in addition to the instructions below, you will also need to 
        edit the context.xml file located in the unpacked WAR file at:<br><br>

        META-INF/context.xml<br><br>

        Change the following line at line 25:<br><br>

        url="jdbc:mysql://localhost:3306/moviedb"<br><br>

        To read:<br><br>

        url="jdbc:mysql://172.31.0.57:3306/moviedb"<br><br>

        Save the file. Now you should be able to do the quick or manual installation as normal. For the Gradle installation, the new build script has commented out remotes for the master and slave private IPs, so just 
        comment out the first remote and uncomment the master remote, deploy, comment the master remote and uncomment
        the slave remote, and deploy again. Note that gradle cargo doesn't support deploying to multiple remotes simultaneously.<br><br>

        <h4>Log Script Usage (Project 5)</h4><br>

        The script to process the log file generated by the search servlet is written in python. It is meant to be run after the file is cleared and after a JMeter test was done. The script has a file clearing option by providing it as a command line argument. The command line argument is “empty”. So, first the script should empty the file as follows:<br><br>

        python getSearchAverages.py empty<br><br>

        Then, after a JMeter test is done, the script should be run again using the above command with or without the “empty” parameter depending on whether the log file should be cleared for another test or not. Either way, the average for TS and for TJ will be displayed and a status message if the file was cleared. If the file is empty, a message will appear indicating that the file is empty.<br><br>


        <h4>Quick Installation</h4><br>

        The WAR file "project5_07.war" included with our submission should be sufficient to
        run the project on a Tomcat server which meets the above requirements. If such a server is not available,
        feel free to install the project to a different directory under webapps on our AWS instance. The webapp
        names we currently deploy to which shouldn't be used are: live_site, chris, stevo, benla.<br><br>

        <span style="font-weight:bold">Tomcat webapps directory on our AWS instance:</span> /opt/tomcat/webapps<br><br>

        If deploying the WAR file as-is doesn't work and the sources need to be recompiled there are two ways to
        accomplish this, the automatic way that we've utilized throughout development, and a kludgy way we
        made for this readme but have only tested twice, but which should be quicker for grading.<br><br>

        <h4>Manual Installation with Java Command Line</h4><br>

        First unpack the WAR file somewhere and navigate to the WEB-INF/classes folder. Delete all of the *.class files from
        here so that they can be recompiled. From that folder:<br><br>

        rm -rf fabflix<br><br>

        Then navigate to the sources folder:<br><br>

        cd ../sources<br><br>

        Run the following command to recompile all of the sources into bytecode in the classes directory:<br><br>

        javac -cp ".:../lib/*" fabflix/beans/*.java fabflix/core/*.java fabflix/filters/*.java -d ../classes<br><br>

        Then move back to the main directory and package it into a WAR file again:<br><br>

        cd ..<br>
        jar cvf ../web_app_name.war .<br>
        cd ..<br>
        ls<br><br>

        Grab the file generated and deploy it using the Tomcat Web Manager, or by manually placing the WAR file in the Tomcat
        webapps directory. As previously mentioned, if deploying to our AWS server, avoid using names live_site, chris, benla, and
        stevo, and note that our webapps directory is:<br><br>

        /opt/tomcat/webapps/<br><br>

        <h4>Automatic Installation with Gradle</h4><br>

        We're utilizing <a href="http://gradle.org/">Gradle</a> as our build and deploy system for the projects.
        In order to utilize our Gradle build scripts, download the files at the following link:<br><br>

        <span style="font-weight:bold"><a href="http://fabflix.me:8080/resources/gradle/gradle.zip">Download Gradle Build Files</a></span> (<span style="font-weight:bold"><a href="https://www.sendspace.com/file/i14elt">Mirror</a></span>)<br><br>

        Extract the ZIP file to any directory, and extract the submitted WAR file as well, deleting all of the *.class files in WEB-INF/classes if desired. Then place all of the contents of the WAR file (META-INF folder, WEB-INF folder, source_xml_parsing folder, resources folder, error.html) in the folder (must be created):<br><br>

        [folder with build.gradle]/src/main/webapp<br><br>

        Now navigate to the folder with build.gradle in it and run the command: ./gradlew -PwAN=your_app_name assemble<br><br>

        This will compile all of the files in the relative 'sources' directory using the JAR files in the 'libs' directory into the 'classes' directory, then create a WAR file in the following location:<br><br>

        [folder with build.gradle]/build/libs/your_app_name.war<br><br>

        Take that WAR file and deploy it to a Tomcat server using the Tomcat Web Manager or by manually placing it in the webapps 
        directory (assuming unpackWARs and autoDeploy are true in its server.xml, which is the case by default).<br><br>

        The build scipt also enables remote deployment but requires some configuration. The server being deployed to must have a 
        Tomcat user with "manager-script" permissions defined in tomcat-users.xml like so:<br><br>

        <code>&lt;user username="scriptuser" password="somesecurepassword" roles="manager-script" /&gt;</code><br><br>

        Then the 'cargo':'remote' section of build.gradle starting at Line 98 should be updated to contain the hostname of the
        server to be deployed to and the username / password combo for the tomcat user specified above. For our AWS server the tomcat user defined in the existing remote declarations within build.gradle will work for each of the three EC2 servers. Once that's done you should be able to run the following command to compile, build, package, deploy, and remove the intermediary WAR:<br><br>

        ./gradlew -PwAN=your_app_name wAD<br><br>

        -or-<br><br>

        ./gradlew -PwAN=your_app_name assemble<br>
        ./gradlew -PwAN=your_app_name cDR<br>
        ./gradlew -PwAN=your_app_name cW<br><br>
    </td>
</tr>